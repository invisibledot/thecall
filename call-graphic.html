<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Call Graphic Generator</title>
  <style>
    body { margin: 0; background: #f6f2df; }
    canvas { display: block; margin: auto; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<script>
let sourceImage;
let tileLayer;

const TILE_SIZE = 100;
const previewWidth = 1200;
const previewHeight = 628;
const bgColor = '#f6f2df';
const colors = ['#ef3f35', '#329758', '#3356a3', '#fae25e', '#f6f2df'];

let scale, minScale, maxScale;
let imgX, imgY;
let imagePlaced = false;
let dragging = false;
let dragOffsetX, dragOffsetY;
let grayscaleMode = true;

let imgInput;

function setup() {
  createCanvas(previewWidth, previewHeight);
  noLoop();

  tileLayer = createGraphics(previewWidth, previewHeight);

  imgInput = createFileInput(handleFile);
  imgInput.position(10, height + 10);
}

function draw() {
  background(bgColor);

  if (!sourceImage) {
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(24);
    text('Upload an image to start', width / 2, height / 2);
    return;
  }

  let scaledWidth = sourceImage.width * scale;
  let scaledHeight = sourceImage.height * scale;

  if (imagePlaced) {
    let filteredImg = getFilteredImage();
    image(filteredImg, imgX, imgY, scaledWidth, scaledHeight);
  } else {
    image(sourceImage, imgX, imgY, scaledWidth, scaledHeight);
  }

  if (imagePlaced) {
    image(tileLayer, 0, 0);
  }
}

function getFilteredImage() {
  let pg = createGraphics(sourceImage.width, sourceImage.height);
  pg.image(sourceImage, 0, 0);

  if (grayscaleMode) {
    pg.filter(GRAY);
  }

  addGrain(pg);
  boostContrast(pg);
  multiplyBlend(pg, bgColor);

  return pg;
}

function addGrain(pg) {
  pg.loadPixels();
  for (let i = 0; i < pg.pixels.length; i += 4) {
    let noiseAmount = random(-15, 15);
    for (let c = 0; c < 3; c++) {
      pg.pixels[i + c] = constrain(pg.pixels[i + c] + noiseAmount, 0, 255);
    }
  }
  pg.updatePixels();
}

function boostContrast(pg) {
  pg.loadPixels();
  const factor = 1.3;
  for (let i = 0; i < pg.pixels.length; i += 4) {
    for (let c = 0; c < 3; c++) {
      let val = pg.pixels[i + c] / 255;
      val = ((val - 0.5) * factor + 0.5) * 255;
      pg.pixels[i + c] = constrain(val, 0, 255);
    }
  }
  pg.updatePixels();
}

function multiplyBlend(pg, bgColorStr) {
  pg.loadPixels();
  let bg = color(bgColorStr);
  let br = red(bg), bgc = green(bg), bb = blue(bg);

  for (let i = 0; i < pg.pixels.length; i += 4) {
    pg.pixels[i]     = (pg.pixels[i]     * br) / 255;
    pg.pixels[i + 1] = (pg.pixels[i + 1] * bgc) / 255;
    pg.pixels[i + 2] = (pg.pixels[i + 2] * bb) / 255;
  }

  pg.updatePixels();
}

function mousePressed() {
  if (!imagePlaced && sourceImage) {
    let w = sourceImage.width * scale;
    let h = sourceImage.height * scale;
    if (mouseX >= imgX && mouseX <= imgX + w &&
        mouseY >= imgY && mouseY <= imgY + h) {
      dragging = true;
      dragOffsetX = mouseX - imgX;
      dragOffsetY = mouseY - imgY;
    }
  }
}

function mouseDragged() {
  if (dragging && !imagePlaced) {
    imgX = mouseX - dragOffsetX;
    imgY = mouseY - dragOffsetY;
    redraw();
  }
}

function mouseReleased() {
  dragging = false;
}

function mouseWheel(event) {
  if (!imagePlaced && sourceImage) {
    let e = event.delta > 0 ? 1 : -1;

    let oldW = sourceImage.width * scale;
    let oldH = sourceImage.height * scale;
    let centerX = imgX + oldW / 2;
    let centerY = imgY + oldH / 2;

    scale -= e * 0.05;
    scale = constrain(scale, minScale, maxScale);

    let newW = sourceImage.width * scale;
    let newH = sourceImage.height * scale;

    imgX = centerX - newW / 2;
    imgY = centerY - newH / 2;
    redraw();
  }
}

function keyPressed() {
  if (key === 'p' || key === 'P') {
    if (!sourceImage) return;
    imagePlaced = true;
    drawTiles();
    redraw();
  } else if ((key === ' ' || keyCode === ENTER) && imagePlaced) {
    drawTiles();
    redraw();
  } else if (key === 's' || key === 'S') {
    if (!imagePlaced) return;
    saveFinalImage();
  } else if (key === 'g' || key === 'G') {
    grayscaleMode = !grayscaleMode;
    redraw();
  }
}

function drawTiles() {
  tileLayer.clear();
  tileLayer.noStroke();

  let cols = ceil(width / TILE_SIZE);
  let rows = ceil(height / TILE_SIZE);
  let gridHeight = rows * TILE_SIZE;
  let offsetYGrid = (height - gridHeight) / 2;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (random(1) < 0.1) {
        let px = x * TILE_SIZE;
        let py = offsetYGrid + y * TILE_SIZE;
        tileLayer.fill(colors[int(random(colors.length))]);
        tileLayer.rect(px, py, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}

function saveFinalImage() {
  let output = createGraphics(width, height);

  if (sourceImage) {
    let w = sourceImage.width * scale;
    let h = sourceImage.height * scale;
    let imgOut = imagePlaced ? getFilteredImage() : sourceImage;
    output.image(imgOut, imgX, imgY, w, h);
  }

  output.image(tileLayer, 0, 0);

  let timestamp = year() + nf(month(), 2) + nf(day(), 2) + "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
  output.save("output-" + timestamp + ".png");
}

function handleFile(file) {
  if (file.type === 'image') {
    loadImage(file.data, img => {
      sourceImage = img;
      resetImagePositionAndScale();
      imagePlaced = false;
      redraw();
    });
  } else {
    console.log("Not an image file!");
  }
}

function resetImagePositionAndScale() {
  scale = width / sourceImage.width;
  minScale = scale * 0.5;
  maxScale = scale * 3;

  let scaledWidth = sourceImage.width * scale;
  let scaledHeight = sourceImage.height * scale;

  imgX = (width - scaledWidth) / 2;
  imgY = (height - scaledHeight) / 2;
}
</script>
</body>
</html>
